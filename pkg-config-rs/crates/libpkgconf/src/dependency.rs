//! Dependency parsing and representation.
//!
//! This module handles parsing dependency specifications from `.pc` file fields
//! like `Requires`, `Requires.private`, `Conflicts`, and `Provides`.
//!
//! Dependency specifications follow the format used by pkg-config/pkgconf:
//!
//! ```text
//! glib-2.0 >= 2.50, gio-2.0, zlib >= 1.2.8
//! ```
//!
//! Packages are separated by commas or whitespace. Each package name can
//! optionally be followed by a version comparator (`=`, `!=`, `<`, `<=`,
//! `>`, `>=`) and a version string.

use crate::version::{self, Comparator};

/// A single dependency entry: a package name with an optional version constraint.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Dependency {
    /// The package name (e.g. `glib-2.0`).
    pub package: String,

    /// The version comparator (defaults to `Any` if no constraint is specified).
    pub compare: Comparator,

    /// The required version string (empty if `compare` is `Any`).
    pub version: Option<String>,

    /// Flags associated with this dependency (e.g. private, internal).
    pub flags: DependencyFlags,
}

impl Dependency {
    /// Create a new dependency with no version constraint.
    pub fn new(package: impl Into<String>) -> Self {
        Self {
            package: package.into(),
            compare: Comparator::Any,
            version: None,
            flags: DependencyFlags::NONE,
        }
    }

    /// Create a new dependency with a version constraint.
    pub fn with_version(
        package: impl Into<String>,
        compare: Comparator,
        version: impl Into<String>,
    ) -> Self {
        Self {
            package: package.into(),
            compare,
            version: Some(version.into()),
            flags: DependencyFlags::NONE,
        }
    }

    /// Check whether a given version satisfies this dependency's constraint.
    ///
    /// If no version constraint is set (`Comparator::Any`), any version satisfies.
    pub fn version_satisfied_by(&self, actual_version: &str) -> bool {
        match &self.version {
            None => true,
            Some(required) => self.compare.eval(actual_version, required),
        }
    }

    /// Return the comparator as a display string, or `None` if `Any`.
    pub fn comparator_str(&self) -> Option<&'static str> {
        if self.compare == Comparator::Any {
            None
        } else {
            Some(self.compare.as_str())
        }
    }
}

impl std::fmt::Display for Dependency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.package)?;
        if let Some(ref ver) = self.version {
            write!(f, " {} {}", self.compare, ver)?;
        }
        Ok(())
    }
}

/// Flags that can be attached to a dependency.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub struct DependencyFlags(u32);

impl DependencyFlags {
    /// No flags set.
    pub const NONE: Self = Self(0x0);
    /// This dependency is internal (e.g. generated by the solver).
    pub const INTERNAL: Self = Self(0x1);
    /// This dependency comes from a `*.private` field.
    pub const PRIVATE: Self = Self(0x2);
    /// This dependency is a query entry (from the command line).
    pub const QUERY: Self = Self(0x4);

    /// Check if a specific flag is set.
    pub fn contains(self, flag: Self) -> bool {
        (self.0 & flag.0) == flag.0
    }

    /// Set a flag, returning the new flags value.
    pub fn with(self, flag: Self) -> Self {
        Self(self.0 | flag.0)
    }

    /// Unset a flag, returning the new flags value.
    pub fn without(self, flag: Self) -> Self {
        Self(self.0 & !flag.0)
    }

    /// Get the raw bits.
    pub fn bits(self) -> u32 {
        self.0
    }
}

/// An ordered list of dependencies.
#[derive(Debug, Clone, Default)]
pub struct DependencyList {
    entries: Vec<Dependency>,
}

impl DependencyList {
    /// Create an empty dependency list.
    pub fn new() -> Self {
        Self {
            entries: Vec::new(),
        }
    }

    /// Parse a dependency specification string (e.g. from a `Requires:` field).
    ///
    /// Accepts the common pkg-config dependency format:
    ///
    /// ```text
    /// glib-2.0 >= 2.50, gio-2.0, zlib >= 1.2.8
    /// foo > 1.0 bar != 2.0
    /// ```
    ///
    /// Packages are separated by commas or whitespace. Each package name may be
    /// followed by a comparator operator and a version string.
    pub fn parse(input: &str) -> Self {
        Self::parse_with_flags(input, DependencyFlags::NONE)
    }

    /// Parse a dependency specification string with the given flags applied to
    /// all resulting dependency entries.
    pub fn parse_with_flags(input: &str, flags: DependencyFlags) -> Self {
        let mut list = Self::new();

        if input.trim().is_empty() {
            return list;
        }

        let mut tokens = DependencyTokenizer::new(input);

        while let Some(package) = tokens.next_package() {
            // After the package name, check if the next token is an operator
            if let Some((compare, ver)) = tokens.try_version_constraint() {
                list.push(Dependency {
                    package,
                    compare,
                    version: Some(ver),
                    flags,
                });
            } else {
                list.push(Dependency {
                    package,
                    compare: Comparator::Any,
                    version: None,
                    flags,
                });
            }
        }

        list
    }

    /// Add a dependency to the end of the list.
    pub fn push(&mut self, dep: Dependency) {
        self.entries.push(dep);
    }

    /// Append all entries from another dependency list.
    pub fn append(&mut self, other: &DependencyList) {
        self.entries.extend(other.entries.iter().cloned());
    }

    /// Return a slice of all dependency entries.
    pub fn entries(&self) -> &[Dependency] {
        &self.entries
    }

    /// Return a mutable slice of all dependency entries.
    pub fn entries_mut(&mut self) -> &mut [Dependency] {
        &mut self.entries
    }

    /// Check if the list is empty.
    pub fn is_empty(&self) -> bool {
        self.entries.is_empty()
    }

    /// Return the number of entries.
    pub fn len(&self) -> usize {
        self.entries.len()
    }

    /// Iterate over the dependency entries.
    pub fn iter(&self) -> impl Iterator<Item = &Dependency> {
        self.entries.iter()
    }

    /// Iterate mutably over the dependency entries.
    pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut Dependency> {
        self.entries.iter_mut()
    }

    /// Remove all entries.
    pub fn clear(&mut self) {
        self.entries.clear();
    }

    /// Format the dependency list as a string suitable for a `.pc` file field value.
    pub fn to_field_value(&self) -> String {
        self.entries
            .iter()
            .map(|d| d.to_string())
            .collect::<Vec<_>>()
            .join(", ")
    }
}

impl IntoIterator for DependencyList {
    type Item = Dependency;
    type IntoIter = std::vec::IntoIter<Dependency>;

    fn into_iter(self) -> Self::IntoIter {
        self.entries.into_iter()
    }
}

impl<'a> IntoIterator for &'a DependencyList {
    type Item = &'a Dependency;
    type IntoIter = std::slice::Iter<'a, Dependency>;

    fn into_iter(self) -> Self::IntoIter {
        self.entries.iter()
    }
}

impl FromIterator<Dependency> for DependencyList {
    fn from_iter<I: IntoIterator<Item = Dependency>>(iter: I) -> Self {
        Self {
            entries: iter.into_iter().collect(),
        }
    }
}

/// Tokenizer for dependency specification strings.
///
/// Splits the input into package names, operators, and version strings,
/// handling commas and whitespace as separators.
struct DependencyTokenizer<'a> {
    input: &'a str,
    pos: usize,
}

impl<'a> DependencyTokenizer<'a> {
    fn new(input: &'a str) -> Self {
        Self { input, pos: 0 }
    }

    /// Skip whitespace and commas (module separators).
    fn skip_separators(&mut self) {
        let bytes = self.input.as_bytes();
        while self.pos < bytes.len() {
            let c = bytes[self.pos];
            if c == b',' || c.is_ascii_whitespace() {
                self.pos += 1;
            } else {
                break;
            }
        }
    }

    /// Peek at the next non-separator character without consuming.
    #[allow(dead_code)]
    fn peek_char(&mut self) -> Option<u8> {
        self.skip_separators();
        self.input.as_bytes().get(self.pos).copied()
    }

    /// Read the next package name token (sequence of non-separator, non-operator chars).
    ///
    /// Returns `None` if we've reached the end of input or the next token starts
    /// with an operator character.
    fn next_package(&mut self) -> Option<String> {
        self.skip_separators();

        let bytes = self.input.as_bytes();
        if self.pos >= bytes.len() {
            return None;
        }

        // If the next char is an operator, something is wrong — skip it
        if version::is_operator_char(bytes[self.pos] as char) {
            return None;
        }

        let start = self.pos;
        while self.pos < bytes.len() {
            let c = bytes[self.pos] as char;
            if version::is_module_separator(c) || version::is_operator_char(c) {
                break;
            }
            self.pos += 1;
        }

        if self.pos > start {
            Some(self.input[start..self.pos].to_string())
        } else {
            None
        }
    }

    /// Try to read a version constraint (operator + version string) after a package name.
    ///
    /// If the next non-separator token is an operator character sequence, parse it
    /// as a comparator followed by a version string.
    ///
    /// Returns `None` if no operator follows (the next token is another package name
    /// or end-of-input).
    fn try_version_constraint(&mut self) -> Option<(Comparator, String)> {
        self.skip_separators();

        let bytes = self.input.as_bytes();
        if self.pos >= bytes.len() {
            return None;
        }

        // Check if the next character is an operator char
        if !version::is_operator_char(bytes[self.pos] as char) {
            return None;
        }

        // Read the operator
        let op_start = self.pos;
        while self.pos < bytes.len() && version::is_operator_char(bytes[self.pos] as char) {
            self.pos += 1;
        }
        let op_str = &self.input[op_start..self.pos];

        let compare = match Comparator::from_str(op_str) {
            Ok(c) => c,
            Err(_) => return None,
        };

        // Skip separators between operator and version
        self.skip_separators();

        // Read the version string
        let ver_start = self.pos;
        while self.pos < bytes.len() {
            let c = bytes[self.pos] as char;
            if version::is_module_separator(c) || version::is_operator_char(c) {
                break;
            }
            self.pos += 1;
        }

        if self.pos > ver_start {
            let ver = self.input[ver_start..self.pos].to_string();
            Some((compare, ver))
        } else {
            // Operator without a version string — treat as if no constraint
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // -------------------------------------------------------------------------
    // Dependency struct
    // -------------------------------------------------------------------------

    #[test]
    fn dependency_new() {
        let dep = Dependency::new("glib-2.0");
        assert_eq!(dep.package, "glib-2.0");
        assert_eq!(dep.compare, Comparator::Any);
        assert!(dep.version.is_none());
        assert_eq!(dep.flags, DependencyFlags::NONE);
    }

    #[test]
    fn dependency_with_version() {
        let dep = Dependency::with_version("zlib", Comparator::GreaterThanEqual, "1.2.8");
        assert_eq!(dep.package, "zlib");
        assert_eq!(dep.compare, Comparator::GreaterThanEqual);
        assert_eq!(dep.version.as_deref(), Some("1.2.8"));
    }

    #[test]
    fn dependency_version_satisfied() {
        let dep = Dependency::with_version("foo", Comparator::GreaterThanEqual, "1.0");
        assert!(dep.version_satisfied_by("1.0"));
        assert!(dep.version_satisfied_by("1.1"));
        assert!(dep.version_satisfied_by("2.0"));
        assert!(!dep.version_satisfied_by("0.9"));
    }

    #[test]
    fn dependency_any_always_satisfied() {
        let dep = Dependency::new("foo");
        assert!(dep.version_satisfied_by("0.0.1"));
        assert!(dep.version_satisfied_by("999.999"));
    }

    #[test]
    fn dependency_display_no_version() {
        let dep = Dependency::new("foo");
        assert_eq!(format!("{}", dep), "foo");
    }

    #[test]
    fn dependency_display_with_version() {
        let dep = Dependency::with_version("foo", Comparator::GreaterThanEqual, "1.0");
        assert_eq!(format!("{}", dep), "foo >= 1.0");
    }

    #[test]
    fn dependency_display_equal() {
        let dep = Dependency::with_version("bar", Comparator::Equal, "2.0");
        assert_eq!(format!("{}", dep), "bar = 2.0");
    }

    #[test]
    fn dependency_comparator_str() {
        let dep = Dependency::new("x");
        assert_eq!(dep.comparator_str(), None);

        let dep2 = Dependency::with_version("x", Comparator::LessThan, "1.0");
        assert_eq!(dep2.comparator_str(), Some("<"));
    }

    // -------------------------------------------------------------------------
    // DependencyFlags
    // -------------------------------------------------------------------------

    #[test]
    fn flags_default_is_none() {
        let flags = DependencyFlags::default();
        assert_eq!(flags, DependencyFlags::NONE);
        assert!(!flags.contains(DependencyFlags::PRIVATE));
        assert!(!flags.contains(DependencyFlags::INTERNAL));
        assert!(!flags.contains(DependencyFlags::QUERY));
    }

    #[test]
    fn flags_with_and_contains() {
        let flags = DependencyFlags::NONE
            .with(DependencyFlags::PRIVATE)
            .with(DependencyFlags::QUERY);
        assert!(flags.contains(DependencyFlags::PRIVATE));
        assert!(flags.contains(DependencyFlags::QUERY));
        assert!(!flags.contains(DependencyFlags::INTERNAL));
    }

    #[test]
    fn flags_without() {
        let flags = DependencyFlags::NONE
            .with(DependencyFlags::PRIVATE)
            .with(DependencyFlags::QUERY)
            .without(DependencyFlags::PRIVATE);
        assert!(!flags.contains(DependencyFlags::PRIVATE));
        assert!(flags.contains(DependencyFlags::QUERY));
    }

    // -------------------------------------------------------------------------
    // DependencyList parsing
    // -------------------------------------------------------------------------

    #[test]
    fn parse_empty() {
        let list = DependencyList::parse("");
        assert!(list.is_empty());
        assert_eq!(list.len(), 0);

        let list2 = DependencyList::parse("   ");
        assert!(list2.is_empty());
    }

    #[test]
    fn parse_single_package() {
        let list = DependencyList::parse("glib-2.0");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].package, "glib-2.0");
        assert_eq!(list.entries()[0].compare, Comparator::Any);
        assert!(list.entries()[0].version.is_none());
    }

    #[test]
    fn parse_multiple_comma_separated() {
        let list = DependencyList::parse("glib-2.0, gio-2.0, zlib");
        assert_eq!(list.len(), 3);
        assert_eq!(list.entries()[0].package, "glib-2.0");
        assert_eq!(list.entries()[1].package, "gio-2.0");
        assert_eq!(list.entries()[2].package, "zlib");
    }

    #[test]
    fn parse_multiple_space_separated() {
        let list = DependencyList::parse("glib-2.0 gio-2.0 zlib");
        assert_eq!(list.len(), 3);
        assert_eq!(list.entries()[0].package, "glib-2.0");
        assert_eq!(list.entries()[1].package, "gio-2.0");
        assert_eq!(list.entries()[2].package, "zlib");
    }

    #[test]
    fn parse_with_version_constraint_gte() {
        let list = DependencyList::parse("glib-2.0 >= 2.50");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].package, "glib-2.0");
        assert_eq!(list.entries()[0].compare, Comparator::GreaterThanEqual);
        assert_eq!(list.entries()[0].version.as_deref(), Some("2.50"));
    }

    #[test]
    fn parse_with_version_constraint_eq() {
        let list = DependencyList::parse("libfoo = 2.0");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].package, "libfoo");
        assert_eq!(list.entries()[0].compare, Comparator::Equal);
        assert_eq!(list.entries()[0].version.as_deref(), Some("2.0"));
    }

    #[test]
    fn parse_with_version_constraint_lt() {
        let list = DependencyList::parse("libbar < 1.0");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].package, "libbar");
        assert_eq!(list.entries()[0].compare, Comparator::LessThan);
        assert_eq!(list.entries()[0].version.as_deref(), Some("1.0"));
    }

    #[test]
    fn parse_with_version_constraint_ne() {
        let list = DependencyList::parse("broken != 3.0");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].package, "broken");
        assert_eq!(list.entries()[0].compare, Comparator::NotEqual);
        assert_eq!(list.entries()[0].version.as_deref(), Some("3.0"));
    }

    #[test]
    fn parse_with_version_constraint_lte() {
        let list = DependencyList::parse("old <= 0.9");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].compare, Comparator::LessThanEqual);
    }

    #[test]
    fn parse_with_version_constraint_gt() {
        let list = DependencyList::parse("new > 5.0");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].compare, Comparator::GreaterThan);
    }

    #[test]
    fn parse_mixed_constrained_and_unconstrained() {
        let list = DependencyList::parse("glib-2.0 >= 2.50, gio-2.0, zlib >= 1.2.8");
        assert_eq!(list.len(), 3);

        assert_eq!(list.entries()[0].package, "glib-2.0");
        assert_eq!(list.entries()[0].compare, Comparator::GreaterThanEqual);
        assert_eq!(list.entries()[0].version.as_deref(), Some("2.50"));

        assert_eq!(list.entries()[1].package, "gio-2.0");
        assert_eq!(list.entries()[1].compare, Comparator::Any);
        assert!(list.entries()[1].version.is_none());

        assert_eq!(list.entries()[2].package, "zlib");
        assert_eq!(list.entries()[2].compare, Comparator::GreaterThanEqual);
        assert_eq!(list.entries()[2].version.as_deref(), Some("1.2.8"));
    }

    #[test]
    fn parse_space_separated_with_constraints() {
        // This mimics command-line style: foo > 1.0 bar != 2.0
        let list = DependencyList::parse("foo > 1.0 bar != 2.0");
        assert_eq!(list.len(), 2);

        assert_eq!(list.entries()[0].package, "foo");
        assert_eq!(list.entries()[0].compare, Comparator::GreaterThan);
        assert_eq!(list.entries()[0].version.as_deref(), Some("1.0"));

        assert_eq!(list.entries()[1].package, "bar");
        assert_eq!(list.entries()[1].compare, Comparator::NotEqual);
        assert_eq!(list.entries()[1].version.as_deref(), Some("2.0"));
    }

    #[test]
    fn parse_with_flags() {
        let list = DependencyList::parse_with_flags("foo >= 1.0, bar", DependencyFlags::PRIVATE);
        assert_eq!(list.len(), 2);
        assert!(list.entries()[0].flags.contains(DependencyFlags::PRIVATE));
        assert!(list.entries()[1].flags.contains(DependencyFlags::PRIVATE));
    }

    #[test]
    fn parse_consecutive_commas() {
        // Multiple commas should just be treated as a single separator
        let list = DependencyList::parse("foo,,bar,,,baz");
        assert_eq!(list.len(), 3);
        assert_eq!(list.entries()[0].package, "foo");
        assert_eq!(list.entries()[1].package, "bar");
        assert_eq!(list.entries()[2].package, "baz");
    }

    #[test]
    fn parse_leading_trailing_separators() {
        let list = DependencyList::parse(" , foo , bar , ");
        assert_eq!(list.len(), 2);
        assert_eq!(list.entries()[0].package, "foo");
        assert_eq!(list.entries()[1].package, "bar");
    }

    #[test]
    fn parse_double_equals() {
        // Some .pc files use == instead of =
        let list = DependencyList::parse("foo == 1.0");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].compare, Comparator::Equal);
        assert_eq!(list.entries()[0].version.as_deref(), Some("1.0"));
    }

    #[test]
    fn parse_complex_package_names() {
        let list = DependencyList::parse("Qt5Core, dbus-1 >= 1.4, x11-xcb");
        assert_eq!(list.len(), 3);
        assert_eq!(list.entries()[0].package, "Qt5Core");
        assert_eq!(list.entries()[1].package, "dbus-1");
        assert_eq!(list.entries()[2].package, "x11-xcb");
    }

    #[test]
    fn parse_version_with_dots() {
        let list = DependencyList::parse("libfoo >= 1.2.3.4");
        assert_eq!(list.entries()[0].version.as_deref(), Some("1.2.3.4"));
    }

    #[test]
    fn parse_version_with_prerelease() {
        let list = DependencyList::parse("libfoo >= 1.0~rc1");
        assert_eq!(list.entries()[0].version.as_deref(), Some("1.0~rc1"));
    }

    // -------------------------------------------------------------------------
    // DependencyList operations
    // -------------------------------------------------------------------------

    #[test]
    fn list_push_and_iterate() {
        let mut list = DependencyList::new();
        list.push(Dependency::new("a"));
        list.push(Dependency::new("b"));
        list.push(Dependency::new("c"));

        let names: Vec<&str> = list.iter().map(|d| d.package.as_str()).collect();
        assert_eq!(names, vec!["a", "b", "c"]);
    }

    #[test]
    fn list_append() {
        let mut list1 = DependencyList::parse("foo, bar");
        let list2 = DependencyList::parse("baz, qux");
        list1.append(&list2);

        assert_eq!(list1.len(), 4);
        assert_eq!(list1.entries()[2].package, "baz");
        assert_eq!(list1.entries()[3].package, "qux");
    }

    #[test]
    fn list_clear() {
        let mut list = DependencyList::parse("foo, bar, baz");
        assert_eq!(list.len(), 3);
        list.clear();
        assert!(list.is_empty());
        assert_eq!(list.len(), 0);
    }

    #[test]
    fn list_into_iter() {
        let list = DependencyList::parse("foo, bar");
        let names: Vec<String> = list.into_iter().map(|d| d.package).collect();
        assert_eq!(names, vec!["foo", "bar"]);
    }

    #[test]
    fn list_from_iterator() {
        let deps = vec![Dependency::new("a"), Dependency::new("b")];
        let list: DependencyList = deps.into_iter().collect();
        assert_eq!(list.len(), 2);
    }

    #[test]
    fn list_to_field_value() {
        let list = DependencyList::parse("glib-2.0 >= 2.50, gio-2.0, zlib >= 1.2.8");
        let field = list.to_field_value();
        assert_eq!(field, "glib-2.0 >= 2.50, gio-2.0, zlib >= 1.2.8");
    }

    #[test]
    fn list_to_field_value_no_constraints() {
        let list = DependencyList::parse("foo, bar, baz");
        let field = list.to_field_value();
        assert_eq!(field, "foo, bar, baz");
    }

    #[test]
    fn list_to_field_value_empty() {
        let list = DependencyList::new();
        let field = list.to_field_value();
        assert_eq!(field, "");
    }

    #[test]
    fn list_entries_mut() {
        let mut list = DependencyList::parse("foo, bar");
        for dep in list.entries_mut() {
            dep.flags = dep.flags.with(DependencyFlags::PRIVATE);
        }
        assert!(list.entries()[0].flags.contains(DependencyFlags::PRIVATE));
        assert!(list.entries()[1].flags.contains(DependencyFlags::PRIVATE));
    }

    // -------------------------------------------------------------------------
    // Real-world examples
    // -------------------------------------------------------------------------

    #[test]
    fn parse_real_world_gtk() {
        let input = "gdk-pixbuf-2.0 >= 2.30.0, cairo >= 1.14.0, cairo-gobject >= 1.14.0, \
                      gdk-3.0 >= 3.22.0, atk >= 2.15.1, atk-bridge-2.0, gio-2.0 >= 2.49.4, \
                      pangocairo >= 1.32.4, pangoft2, glib-2.0 >= 2.49.4, epoxy >= 1.0, \
                      fribidi >= 0.19.7";
        let list = DependencyList::parse(input);
        assert_eq!(list.len(), 12);
        assert_eq!(list.entries()[0].package, "gdk-pixbuf-2.0");
        assert_eq!(list.entries()[0].compare, Comparator::GreaterThanEqual);
        assert_eq!(list.entries()[0].version.as_deref(), Some("2.30.0"));

        // atk-bridge-2.0 has no version constraint
        let atk_bridge = list.iter().find(|d| d.package == "atk-bridge-2.0").unwrap();
        assert_eq!(atk_bridge.compare, Comparator::Any);
        assert!(atk_bridge.version.is_none());

        // pangoft2 has no version constraint
        let pangoft2 = list.iter().find(|d| d.package == "pangoft2").unwrap();
        assert_eq!(pangoft2.compare, Comparator::Any);
    }

    #[test]
    fn parse_real_world_simple_requires() {
        let list = DependencyList::parse("libcrypto");
        assert_eq!(list.len(), 1);
        assert_eq!(list.entries()[0].package, "libcrypto");
        assert_eq!(list.entries()[0].compare, Comparator::Any);
    }

    #[test]
    fn roundtrip_field_value() {
        let input = "glib-2.0 >= 2.50, gio-2.0, zlib >= 1.2.8";
        let list = DependencyList::parse(input);
        let output = list.to_field_value();
        let reparsed = DependencyList::parse(&output);

        assert_eq!(list.len(), reparsed.len());
        for (a, b) in list.iter().zip(reparsed.iter()) {
            assert_eq!(a.package, b.package);
            assert_eq!(a.compare, b.compare);
            assert_eq!(a.version, b.version);
        }
    }
}
